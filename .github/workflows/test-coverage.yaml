name: Run tests and coverage

on:
  pull_request:
    branches:
      - master

permissions:
  contents: write
  pull-requests: read

jobs:
  build-test-coverage:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"

      - name: Restore dependencies
        run: dotnet restore backend/code/code.sln

      - name: Build project
        run: dotnet build backend/code/code.sln --configuration Release --no-restore

      - name: Run tests and collect coverage
        run: |
          dotnet test backend/code/code.sln --configuration Release --no-build \
            --collect:"XPlat Code Coverage" \
            --results-directory ./coverage \
            --logger "trx;LogFileName=testresults.trx" \
            /p:CollectCoverage=true \
            /p:CoverletOutputFormat=cobertura \
            /p:CoverletOutput=./coverage/coverage.cobertura.xml

      - name: Locate Cobertura coverage file
        id: locate_coverage_file
        run: |
          EXPECTED_COVERAGE_FILE="./coverage/coverage.cobertura.xml"
          if [ -f "$EXPECTED_COVERAGE_FILE" ]; then
            echo "Coverage file found at: $EXPECTED_COVERAGE_FILE"
            echo "file_path=$EXPECTED_COVERAGE_FILE" >> $GITHUB_OUTPUT
            echo "file_exists=true" >> $GITHUB_OUTPUT
          else
            # Fallback: Search recursively if the explicitly named file isn't found
            echo "Expected coverage file $EXPECTED_COVERAGE_FILE not found. Searching recursively..."
            # Look for any file named coverage.cobertura.xml in subdirectories of ./coverage
            COVERAGE_FILE_PATH=$(find ./coverage -type f -name "coverage.cobertura.xml" -print -quit)
            if [ -f "$COVERAGE_FILE_PATH" ]; then
              echo "Fallback: Coverage file found at: $COVERAGE_FILE_PATH"
              echo "file_path=$COVERAGE_FILE_PATH" >> $GITHUB_OUTPUT
              echo "file_exists=true" >> $GITHUB_OUTPUT
            else
              echo "Coverage file (coverage.cobertura.xml) not found in ./coverage directory or its subdirectories."
              # Create a dummy file with 0% coverage
              mkdir -p ./coverage/dummy
              echo '<coverage line-rate="0" branch-rate="0" lines-covered="0" lines-valid="1" complexity="0" version="0" timestamp="0"></coverage>' > ./coverage/dummy/cobertura.xml
              echo "file_path=./coverage/dummy/cobertura.xml" >> $GITHUB_OUTPUT
              echo "file_exists=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Calculate coverage percentage
        id: coverage_percentage
        if: steps.locate_coverage_file.outputs.file_path
        run: |
          COVERAGE_FILE="${{ steps.locate_coverage_file.outputs.file_path }}"
          echo "Parsing coverage data from: $COVERAGE_FILE"
          # Using Python to parse XML as it's cross-platform and handles XML robustly.
          # Python is available on GitHub's ubuntu-latest runners.
          PERCENTAGE=$(python -c "
          import xml.etree.ElementTree as ET
          import sys
          try:
              tree = ET.parse('$COVERAGE_FILE')
              root = tree.getroot()
              line_rate = float(root.get('line-rate', '0')) # Default to 0 if attribute missing
              percentage = round(line_rate * 100, 2)
              print(percentage)
          except Exception as e:
              print(f'Error parsing XML: {e}', file=sys.stderr)
              print('0.00') # Default to 0.00 on any parsing error
          ")
          echo "Raw percentage from Python: $PERCENTAGE"
          # Validate that PERCENTAGE is a number, default to 0 if not
          if ! [[ "$PERCENTAGE" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
            echo "Warning: Python script output was not a valid number ('$PERCENTAGE'). Defaulting to 0."
            PERCENTAGE="0.00"
          fi
          echo "Calculated Coverage: $PERCENTAGE%"
          echo "percentage=$PERCENTAGE" >> $GITHUB_OUTPUT
          # Set an environment variable for easy use in subsequent steps
          echo "COVERAGE_PERCENTAGE_VALUE=$PERCENTAGE" >> $GITHUB_ENV

      - name: Generate Coverage Badge URL
        id: coverage_badge
        if: steps.coverage_percentage.outputs.percentage # Proceed if percentage was calculated
        run: |
          PERCENTAGE=${{ env.COVERAGE_PERCENTAGE_VALUE }}
          # Determine color based on percentage for the badge
          COLOR="red" # Default color
          if (( $(echo "$PERCENTAGE >= 90" | bc -l) )); then
            COLOR="brightgreen"
          elif (( $(echo "$PERCENTAGE >= 80" | bc -l) )); then
            COLOR="green"
          elif (( $(echo "$PERCENTAGE >= 70" | bc -l) )); then
            COLOR="yellowgreen"
          elif (( $(echo "$PERCENTAGE >= 60" | bc -l) )); then
            COLOR="yellow"
          elif (( $(echo "$PERCENTAGE >= 50" | bc -l) )); then
            COLOR="orange"
          fi
          BADGE_URL="https://img.shields.io/badge/coverage-$PERCENTAGE%25-$COLOR"
          echo "Badge URL: $BADGE_URL"
          echo "url=$BADGE_URL" >> $GITHUB_OUTPUT
          # Store the full Markdown for the badge
          echo "COVERAGE_BADGE_MARKDOWN=![Coverage]($BADGE_URL)" >> $GITHUB_ENV

      # 9. Update README.md in workspace
      - name: Update README.md
        if: steps.coverage_badge.outputs.url
        run: |
          README_FILE="README.md"
          # IMPORTANT: Ensure this exact placeholder is in your README.md on its own line for the FIRST run.
          PLACEHOLDER="placeholder"
          # Regex to find an existing coverage badge (from shields.io, with "Coverage" alt text)
          EXISTING_BADGE_REGEX="^\!\[Coverage\]\(https://img\.shields\.io/badge/coverage-.*\)$"
          BADGE_MARKDOWN="${{ env.COVERAGE_BADGE_MARKDOWN }}"
          TEMP_README="tmp_readme.md"

          if [ ! -f "$README_FILE" ]; then
            echo "$README_FILE not found! Cannot update badge."
            exit 1 # Fail the step if README doesn't exist
          fi

          # Try to replace the placeholder first
          if grep -qF "$PLACEHOLDER" "$README_FILE"; then
            echo "Placeholder found. Replacing with new badge."
            # Use awk to replace the placeholder line
            awk -v placeholder_pattern="^${PLACEHOLDER}$" -v badge="$BADGE_MARKDOWN" '
              $0 ~ placeholder_pattern { print badge; next }
              { print }
            ' "$README_FILE" > "$TEMP_README" && mv "$TEMP_README" "$README_FILE"
          # If placeholder not found, try to replace an existing badge
          elif grep -qE "$EXISTING_BADGE_REGEX" "$README_FILE"; then
            echo "Existing badge found. Replacing with new badge."
            # Use awk to replace the line matching the existing badge regex
            awk -v badge_regex="$EXISTING_BADGE_REGEX" -v new_badge="$BADGE_MARKDOWN" '
              $0 ~ badge_regex { print new_badge; next }
              { print }
            ' "$README_FILE" > "$TEMP_README" && mv "$TEMP_README" "$README_FILE"
          else
            echo "Neither placeholder nor existing badge pattern found in $README_FILE."
            echo "Please add '$PLACEHOLDER' to your README.md file on its own line."
            # Or, if you want to append it if nothing is found:
            # echo "$BADGE_MARKDOWN" >> "$README_FILE"
            # echo "Badge appended to README.md as no placeholder or existing badge was found."
          fi
          echo "README.md processed for badge update."

      # 10. Commit and Push README changes if they exist
      - name: Commit and Push README changes
        if: steps.coverage_badge.outputs.url # Only run if badge was generated
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

          # Check if README.md was actually modified
          if git diff --quiet README.md; then
            echo "No changes to README.md to commit. Badge was already up-to-date or placeholder/existing badge was not found/updated correctly."
          else
            echo "README.md was modified. Committing changes..."
            git add README.md
            # The '[skip ci]' in the commit message is a convention to prevent CI loops.
            git commit -m "docs: Update test coverage badge [skip ci]"
            git push origin HEAD:${{ github.head_ref }}
            echo "Pushed README.md changes to branch ${{ github.head_ref }}."
          fi
